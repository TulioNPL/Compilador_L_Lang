Dec -> ( int (1)| boolean (2)| char (3)) ID (4) [:= [-]CONST (5) | "[" CONST (6) "]" ] (8) {, ID (4) [:= [-]CONST (5) | "[" CONST (6) "]" ] (8)} ; | final (7) ID (10) = [-]CONST (9) ; (8)
(1) { 
  Dec.tipo = inteiro; dec.classe = classe_var 
}
(2) { 
  Dec.tipo = boolean; dec.classe = classe_var
}
(3) { 
  Dec.tipo = char; dec.classe = classe_var 
}
(4) { 
  se (id.tipo == vazio) entao 
        id.tipo = dec.tipo; id.classe = dec.classe
  senao ERRO "ID já declarado" 
}
(5) { 
  se (nao verificaCompatibDec(dec.tipo, const.tipo)) entao erro "TIPOS INCOMPATIVEIS"
}
(6) { 
  se (const.val <= 8kbytes) entao 
        (id.tamanho = const.val) 
  senao erro "Tamanho excedido" 
}
(7) { 
    Dec.classe = classe_const
}
(8) { 
    Tabela[id.pos]->tamanho = id_tamanho
    Tabela[id.pos]->classe = dec_classe
    Tabela[id.pos]->tipo = dec_tipo
    Tabela[id.pos]->endereco = contadorDados (posição atual do contador de dados)
    //gera instrução para declaração (método printDec())
}
(9) { 
    dec_tipo = const_tipo 
}
(10) { 
    se (id.tipo == vazio) entao 
        id.classe = dec.classe
    senao erro "ID já declarado"
}

_______________________________________________________________________________________________________________________________________________________________________________________________________

F -> not F1 (1) | "(" Exp (2) ")" | CONST (3) | ID (4) [ "[" Exp (5) "]" ]
(1) { 
    se (f1.tipo != boolean) entao ERRO  "Tipos incompativeis"; 
    f.tipo = f1.tipo; 
    f.tamanho = f1.tamanho; 
    f.end = novoTemp()
    mov regA,ds:[f1.end]
    neg regA
    add regA,1
    mov ds:[f.end], regA
}
(2) { 
    f.tipo = exp.tipo
    f.tamanho = exp.tamanho
    f.end = exp.end
}
(3) { 
    f.tipo = const.tipo; 
    se (const.tipo != string) 
        f.tamanho = 0;
        F.end = novoTemp()
        mov regA, imed
        mov ds:[F.end], regA
    senao 
        f.tamanho = const.tamanho; 
         declarar constante na area de dados
        dseg SEGMENT PUBLIC
          byte "const.lex$" 
        dseg ENDS
        f.end = contadorDados
        contadorDados += const.tamanho
}
(4) { 
    se id.tipo == TIPO_VAZIO entao 
      ERRO "ID nao declarado"
    senao
      f.tipo = id.tipo
      f.tamanho = id.tamanho 
      f.end = id.end
}
(5) { 
    se (exp.tipo != inteiro || exp.tamanho > 0) entao ERRO "Tipos incompativeis"; 
    senao
      F.end = novoTemp()
      mov AX, DS:[Exp.end]
      if(f.tipo == TIPO_INT) entao
        add AX, DS:[Exp.end]
      add id.end AX
      mov bx, DS:[ax]
      mov ds:[f.end], bx

}


T ->  F1 (1) { ( * (2) | / (3) | % (4) | and (5) ) F2 (6) }
(1) { 
    t.tipo = f1.tipo; 
    t.tamanho = f1.tamanho; 
    t.end = f1.end;
}
(2) { 
    t.op = mult; 
}
(3) { 
    t.op = div; 
}
(4) { 
    t.op = mod; 
}
(5) { 
    t.op = and; 
    t.tipo = boolean;
}
(6) { 
    se não(verificaOps()) entao ERRO "Tipos incompativeis"
    mov ax, ds:[t.end]
    mov bx, ds:[f2.end]
    se t.op == mult entao
        imul bx
    senao se t.op == div entao 
        cwd
        idiv bx
    senao se t.op == mod entao
        cwd
        idiv bx
        mov ax, dx // move resto para o registrador Ax
    senao 
        imul bx
        

    t.end = novoTemp();
    mov ds:[t.end], ax
}




ExpS -> [ + | - (6)] T1 (1) { ( + (2) | - (3) | or (4) ) T2 (5) }
(1) {
     exps.tipo = t1.tipo; 
     exps_tamanho = t1.tamanho;
     exps.end = T1.end;
     se boolNeg == True entao
        mov ax,ds:[exps.end]
        neg ax
        mov ds:[exps.end], ax
}
(2) {
     exps.op = add 
}
(3) {
     exps.op = sub
 }
(4) {
     exps.op = or; 
     exps.tipo = boolean;
}
(5) {
    verificaOps;
    mov ax, ds:[exps.end]
    mov bx, ds:[t2.end]
    se exps.op == add entao
        add ax, bx
    senao se exps.op == sub entao 
        sub ax, bx
    senao
        //fazer o or
        // a + b - (a * b)
        mov cx,ax // salva valor de AX em CX
        imul bx // ax = a * b
        add bx, cx // bx = a + b
        sub bx, ax // a + b - (a*b)
        mov ax, bx // move pro Ax o resultado
    
    exps.end = novoTemp()
    mov ds:[exps.end], ax
}
(6) {
    se token == TOKEN_MENOS entao boolNeg = True;
}



Exp -> ExpS1 (1) [ ( = | > | < | <> | <= | >= ) (2) ExpS2 (3) ]
(1) {
     exp_tipo = exps1_tipo; 
     exp.tamanho = exps1.tamanho; 
     exp.end = exps1.end; 
}
(2) {
    expop = Token_OP;
    exp_tipo = boolean; 
    exp.tamanho = 0;
}
(3) {
    se nao(VerificaOps) entao ERRO "Tipos incompativeis"
    mov ax, ds:[exp.end]
    mov bx, ds:[exp2.end]
    cmp ax, bx
    RotVerdadeiro = novoRot()
    se expop == token_igual entao
        je RotVerdadeiro
    senao se expop == token_dif entao
        jne RotVerdadeiro
    senao se expop == token_menor entao
        jl RotVerdadeiro
    senao se expop == token_maior entao
        jg RotVerdadeiro
    senao se expop == token_maior_igual entao
        jge RotVerdadeiro
    senao 
        jle RotVerdadeiro

    se (exps1.tipo == STRING || exps1.tipo == Char[] && exps2.tipo == STRING || exps2.tipo == Char[]) entao
        string comecoCmp, iguais, fimCmp;
        comecoCmp = novoRot();
        iguais = novoRot();
        fimCmp = novoRot();

        mov ax, 1
        mov bx, ds:[exps1_end]
        mov cx, ds:[exps2_end]
        mov dx, 0
        comecoCmp:
        cmp bx, ax
        je iguais:
        mov ax, 0 //se forem diferentes, ax recebe 0 e acaba o loop
        jmp fimCmp
        iguais:
        cmp bx, '$'
        je fimCmp
        cmp cx '$'
        je fimCmp
        add dx, 1 //incrementa a posicao
        mov bx, exps1_en //mov end pra ax
        add bx, dx //soma a posicao
        mov cx, exps2_en //move o end pra bx
        add cx, dx // soma posicao
        mov bx, ds:[ax] //atualiza o char de ax
        mov cx, ds:[bx] // atualiza o char de bx
        jmp comecoCmp
        fimCmp:
    senao 
        mov AX, 0
        RotFim = novoRot()
        jmp RotFim
        RotVerdadeiro:
        mov AX, 1
        RotFim:

    exp_end = novoTemp()
    exp_tipo = TIPO_BOOLEAN
    mov ds:[exp_end], AX    
}

_______________________________________________________________________________________________________________________________________________________________________________________________________


CmdAtr -> ID (1) ["[" Exp (2) "]"] := Exp1 (3)
(1) { 
    se id.tipo == vazio entao ERRO "id não declarado" 
    senao atr.tipo = id_tipo; 
    se id.classe == classe_const then ERRO "classe incompativel"

    mov ax, id_end // move id pra AX
  
}
(2) { 
    se (exp.tipo != tipo_int) entao erro "tipos incompativeis"
    add ax , ds:[exp.end] // adiciona valor da expressao pra AX para calcular posicao
    se atr_tipo == TIPO_INT entao
        add ax, ds:[exp.end]
}
(3) { 
  se (nao compativel(atr.tipo, exp1.tipo)) entao ERRO "tipos incompativeis"
  senao
    mov bx, ds:[exp1.end]
    mov ds:[ax], bx
}
_______________________________________________________________________________________________________________________________________________________________________________________________________

CmdWrite -> (write|writeln(2))"(" Exp (1) {, Exp (1) } ")" (3)
(1) { 
    se exp.tipo != int || char || string entao ERRO  "Tipos incompativeis"
    senao
            mov di, string.end ;end. string temp.
            mov cx, 0 ;contador
            cmp ax,0 ;verifica sinal
            jge R0 ;salta se número positivo
            mov bl, 2Dh ;senão, escreve sinal –
            mov ds:[di], bl
            add di, 1 ;incrementa índice
            neg ax ;toma módulo do número
        R0 = novoRot()
        R0:
            mov bx, 10 ;divisor
        R1 = novoRot()
        R1:
            add cx, 1 ;incrementa contador
            mov dx, 0 ;estende 32bits p/ div.
            idiv bx ;divide DXAX por BX
            push dx ;empilha valor do resto
            cmp ax, 0 ;verifica se quoc. é 0
            jne R1 ;se não é 0, continua
            ;agora, desemp. os valores e escreve o string
        R2 = novoRot()
        R2:
            pop dx ;desempilha valor
            add dx, 30h ;transforma em caractere
            mov ds:[di],dl ;escreve caractere
            add di, 1 ;incrementa base
            add cx, -1 ;decrementa contador
            cmp cx, 0 ;verifica pilha vazia
            jne R2 ;se não pilha vazia, loop
            ;grava fim de string
            mov dl, 024h ;fim de string
            mov ds:[di], dl ;grava '$'
            ;exibe string
            mov dx, string.end
            mov ah, 09h
            int 21h

    se linha entao //imprime quebra de linha
        mov ah, 02h
        mov dl, 0Dh
        int 21h
        mov DL, 0Ah
        int 21h
}
(2) { line = true }
_______________________________________________________________________________________________________________________________________________________________________________________________________


CmdRead -> readln "(" ID (2) ["[" Exp (3) "]"] (1) ")"
(1) -> { se id.tipo != int || char || string e for vetor entao ERRO }
(2) -> { se id.tipo == VAZIO entao ERRO}
(3) -> { se exp.tipo != int && exp.tamanho > 0 entao ERRO }
_______________________________________________________________________________________________________________________________________________________________________________________________________

CmdIf -> if"(" Exp (1) ")" then (Cmd | BlocoCmd) [else (Cmd | BlocoCmd)]
(1) -> { se exp.tipo != BOOLEAN || exp.tamanho > 0 entao ERRO }

_______________________________________________________________________________________________________________________________________________________________________________________________________

CmdRep -> for"(" [CmdFor {, CmdFor}]; Exp (1); [CmdFor {, CmdFor}] ")" (Cmd | BlocoCmd)
(1) -> { se exp.tipo != BOOLEAN || exp.tamanho > 0 entao ERRO }

_______________________________________________________________________________________________________________________________________________________________________________________________________


CmdP -> CmdAtr | CmdWrite | CmdRead

Cmd -→ [CmdP] ; | CmdFor | CmdIf

CmdFor -> CmdAtr | CmdWrite | CmdRead | CmdFor | CmdIf

BlocoCmd -> "{" { Cmd } "}"



Prog -> { Dec } main BlocoCmd EOF
Dec -> ( int (1)| boolean (2)| char (3)) ID (4) [:= [-]CONST (5) | "[" CONST (6) "]" ] (8) {, ID (4) [:= [-]CONST (5) | "[" CONST (6) "]" ] (8)} ; | final (7) ID (10) = [-]CONST (9) ; (8)

(1) { 
  Dec.tipo = inteiro; dec.classe = classe_var 
}
(2) { 
  Dec.tipo = boolean; dec.classe = classe_var
}
(3) { 
  Dec.tipo = char; dec.classe = classe_var 
}
(4) { 
  se (id.tipo == vazio) entao 
        id.tipo = dec.tipo; id.classe = dec.classe
  senao ERRO "ID já declarado" 
}
(5) { 
  se (nao verificaCompatibDec(dec.tipo, const.tipo)) entao erro "TIPOS INCOMPATIVEIS"
}
(6) { 
  se (const.val <= 8kbytes) entao 
        (id.tamanho = const.val) 
  senao erro "Tamanho excedido" 
}
(7) { 
    Dec.classe = classe_const
}
(8) { 
    Tabela[id.pos]->tamanho = id_tamanho
    Tabela[id.pos]->classe = dec_classe
    Tabela[id.pos]->tipo = dec_tipo
    Tabela[id.pos]->endereco = contadorDados (posição atual do contador de dados)
    //gera instrução para declaração (método printDec())
}
(9) { 
    dec_tipo = const_tipo 
}
(10) { 
    se (id.tipo == vazio) entao 
        id.classe = dec.classe
    senao erro "ID já declarado"
}

_______________________________________________________________________________________________________________________________________________________________________________________________________

F -> not F1 (1) | "(" Exp (2) ")" | CONST (3) | ID (4) [ "[" Exp (5) "]" ]
(1) { 
    se (f1.tipo != boolean) entao ERRO  "Tipos incompativeis"; 
    f.tipo = f1.tipo; 
    f.tamanho = f1.tamanho; 
    f.end = novoTemp()
    mov regA,ds:[f1.end]
    neg regA
    add regA,1
    mov ds:[f.end], regA
}
(2) { 
    f.tipo = exp.tipo
    f.tamanho = exp.tamanho
    f.end = exp.end
}
(3) { 
    f.tipo = const.tipo; 
    se (const.tipo != string) 
        f.tamanho = 0;
        F.end = novoTemp()
        mov regA, imed
        mov ds:[F.end], regA
    senao 
        f.tamanho = const.tamanho; 
         declarar constante na area de dados
        dseg SEGMENT PUBLIC
          byte "const.lex$" 
        dseg ENDS
        f.end = contadorDados
        contadorDados += const.tamanho
}
(4) { 
    se id.tipo == TIPO_VAZIO entao 
      ERRO "ID nao declarado"
    senao
      f.tipo = id.tipo
      f.tamanho = id.tamanho 
      f.end = id.end
}
(5) { 
    se (exp.tipo != inteiro || exp.tamanho > 0) entao ERRO "Tipos incompativeis"; 
    senao
      F.end = novoTemp()
      mov AX, DS:[Exp.end]
      if(f.tipo == TIPO_INT) entao
        add AX, DS:[Exp.end]
      add id.end AX
      mov bx, DS:[ax]
      mov ds:[f.end], bx

}


// T ->  F1 (1) { ( * (2) | / (3) | % (4) | and (5) ) F2 (6) }

(1) { 
    t.tipo = f1.tipo; 
    t.tamanho = f1.tamanho; 
    t.end = f1.end;
}
(2) { 
    t.op = mult; 
}
(3) { 
    t.op = div; 
}
(4) { 
    t.op = mod; 
}
(5) { 
    t.op = and; 
    t.tipo = boolean;
}
(6) { 
    se não(verificaOps()) entao ERRO "Tipos incompativeis"
    mov ax, ds:[t.end]
    mov bx, ds:[f2.end]
    se t.op == mult entao
        imul bx
    senao se t.op == div entao 
        cwd
        idiv bx
    senao se t.op == mod entao
        cwd
        idiv bx
        mov ax, dx // move resto para o registrador Ax
    senao 
        imul bx
        

    t.end = novoTemp();
    mov ds:[t.end], ax
}




// ExpS -> [ + | - (6)] T1 (1) { ( + (2) | - (3) | or (4) ) T2 (5) }
(1) {
     exps.tipo = t1.tipo; 
     exps_tamanho = t1.tamanho;
     exps.end = T1.end;
     se boolNeg == True entao
        mov ax,ds:[exps.end]
        neg ax
        mov ds:[exps.end], ax
}
(2) {
     exps.op = add 
}
(3) {
     exps.op = sub
 }
(4) {
     exps.op = or; 
     exps.tipo = boolean;
}
(5) {
    verificaOps;
    mov ax, ds:[exps.end]
    mov bx, ds:[t2.end]
    se exps.op == add entao
        add ax, bx
    senao se exps.op == sub entao 
        sub ax, bx
    senao
        //fazer o or
        // a + b - (a * b)
        mov cx,ax // salva valor de AX em CX
        imul bx // ax = a * b
        add bx, cx // bx = a + b
        sub bx, ax // a + b - (a*b)
        mov ax, bx // move pro Ax o resultado
    
    exps.end = novoTemp()
    mov ds:[exps.end], ax
}
(6) {
    se token == TOKEN_MENOS entao boolNeg = True;
}



// Exp -> ExpS1 (1) [ ( = | > | < | <> | <= | >= ) (2) ExpS2 (3) ]

(1) {
     exp_tipo = exps1_tipo; 
     exp.tamanho = exps1.tamanho; 
     exp.end = exps1.end; 
}
(2) {
    expop = Token_OP;
    exp_tipo = boolean; 
    exp.tamanho = 0;
}
(3) {
    se nao(VerificaOps) entao ERRO "Tipos incompativeis"
    mov ax, ds:[exp.end]
    mov bx, ds:[exp2.end]
    cmp ax, bx
    RotVerdadeiro = novoRot()
    se expop == token_igual entao
        je RotVerdadeiro
    senao se expop == token_dif entao
        jne RotVerdadeiro
    senao se expop == token_menor entao
        jl RotVerdadeiro
    senao se expop == token_maior entao
        jg RotVerdadeiro
    senao se expop == token_maior_igual entao
        jge RotVerdadeiro
    senao 
        jle RotVerdadeiro

    mov AX, 0
    RotFim = novoRot()
    jmp RotFim
    RotVerdadeiro:
    mov AX, 1
    RotFim:

    exp_end = novoTemp()
    exp_tipo = TIPO_BOOLEAN
    mov ds:[exp_end], AX    
}

_______________________________________________________________________________________________________________________________________________________________________________________________________


// CmdAtr -> ID (1) ["[" Exp (2) "]"] := Exp1 (3)

(1) { 
  se id.tipo == vazio entao ERRO "id não declarado" 
  senao atr.tipo = id_tipo; 

  se id.classe == classe_const then ERRO "classe incompativel"
}
(2) { 
  se (exp.tipo != tipo_int) entao erro "tipos incompativeis"
}
(3) { 
  se (nao compativel(atr.tipo, exp1.tipo)) entao ERRO "tipos incompativeis"
  senao
    mov ax , ds:[exp.end]
    se atr_tipo == TIPO_INT entao
        add ax, ds:[exp.end]
    add ax, id.end
    mov bx, ds:[exp1.end]
    mov ds:[ax], bx
}
_______________________________________________________________________________________________________________________________________________________________________________________________________

// CmdWrite -> (write|writeln)"(" Exp (1) {, Exp (1) } ")"
// CmdWrite -> write"(" Exp {, Exp } ")" | writeln"(" Exp {, Exp } ")" (2) <- fazer dps kkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkk

// (1) { if exp.tipo != int || char || string entao ERRO }
_______________________________________________________________________________________________________________________________________________________________________________________________________


CmdRead -> readln "(" ID (2) ["[" Exp (3) "]"] (1) ")"

(1) -> { se id.tipo != int || char || string e for vetor entao ERRO }
(2) -> { se id.tipo == VAZIO entao ERRO}
(3) -> { se exp.tipo != int && exp.tamanho > 0 entao ERRO }
_______________________________________________________________________________________________________________________________________________________________________________________________________

CmdIf -> if"(" Exp (1) ")" then (Cmd | BlocoCmd) [else (Cmd | BlocoCmd)]

(1) -> { se exp.tipo != BOOLEAN || exp.tamanho > 0 entao ERRO }

_______________________________________________________________________________________________________________________________________________________________________________________________________

CmdRep -> for"(" [CmdFor {, CmdFor}]; Exp (1); [CmdFor {, CmdFor}] ")" (Cmd | BlocoCmd)

(1) -> { se exp.tipo != BOOLEAN || exp.tamanho > 0 entao ERRO }

_______________________________________________________________________________________________________________________________________________________________________________________________________


CmdP -> CmdAtr | CmdWrite | CmdRead

Cmd -→ [CmdP] ; | CmdFor | CmdIf

CmdFor -> CmdAtr | CmdWrite | CmdRead | CmdFor | CmdIf

BlocoCmd -> "{" { Cmd } "}"



Prog -> { Dec } main BlocoCmd EOF
